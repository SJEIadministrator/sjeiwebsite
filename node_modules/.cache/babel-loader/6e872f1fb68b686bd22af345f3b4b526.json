{"ast":null,"code":"var _jsxFileName = \"/Users/riteshgupta/Desktop/sjeiwebsite/src/components/UncontrolledTabs.js\";\nimport PropTypes from \"prop-types\";\nimport React, { cloneElement, Component } from \"react\";\nimport cx from \"clsx\";\nimport uuid from \"./helpers/uuid\";\nimport { childrenPropType } from \"./helpers/propTypes\";\nimport { getPanelsCount, getTabsCount } from \"./helpers/count\";\nimport { deepMap } from \"./helpers/childrenDeepMap\";\nimport { isTabList, isTabPanel, isTab } from \"./helpers/elementTypes\";\n\nfunction isNode(node) {\n  return node && \"getAttribute\" in node;\n} // Determine if a node from event.target is a Tab element\n\n\nfunction isTabNode(node) {\n  return isNode(node) && node.getAttribute(\"role\") === \"tab\";\n} // Determine if a tab node is disabled\n\n\nfunction isTabDisabled(node) {\n  return isNode(node) && node.getAttribute(\"aria-disabled\") === \"true\";\n}\n\nlet canUseActiveElement;\n\ntry {\n  canUseActiveElement = !!(typeof window !== \"undefined\" && window.document && window.document.activeElement);\n} catch (e) {\n  // Work around for IE bug when accessing document.activeElement in an iframe\n  // Refer to the following resources:\n  // http://stackoverflow.com/a/10982960/369687\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12733599\n  canUseActiveElement = false;\n}\n\nexport default class UncontrolledTabs extends Component {\n  constructor(...args) {\n    super(...args);\n    this.tabNodes = [];\n\n    this.handleKeyDown = e => {\n      const {\n        direction\n      } = this.props;\n\n      if (this.isTabFromContainer(e.target)) {\n        let {\n          selectedIndex: index\n        } = this.props;\n        let preventDefault = false;\n        let useSelectedIndex = false;\n\n        if (e.keyCode === 32 || e.keyCode === 13) {\n          preventDefault = true;\n          useSelectedIndex = false;\n          this.handleClick(e);\n        }\n\n        if (e.keyCode === 37 || e.keyCode === 38) {\n          // Select next tab to the left\n          if (direction === \"rtl\") {\n            index = this.getNextTab(index);\n          } else {\n            index = this.getPrevTab(index);\n          }\n\n          preventDefault = true;\n          useSelectedIndex = true;\n        } else if (e.keyCode === 39 || e.keyCode === 40) {\n          // Select next tab to the right\n          if (direction === \"rtl\") {\n            index = this.getPrevTab(index);\n          } else {\n            index = this.getNextTab(index);\n          }\n\n          preventDefault = true;\n          useSelectedIndex = true;\n        } else if (e.keyCode === 35) {\n          // Select last tab (End key)\n          index = this.getLastTab();\n          preventDefault = true;\n          useSelectedIndex = true;\n        } else if (e.keyCode === 36) {\n          // Select first tab (Home key)\n          index = this.getFirstTab();\n          preventDefault = true;\n          useSelectedIndex = true;\n        } // This prevents scrollbars from moving around\n\n\n        if (preventDefault) {\n          e.preventDefault();\n        } // Only use the selected index in the state if we're not using the tabbed index\n\n\n        if (useSelectedIndex) {\n          this.setSelected(index, e);\n        }\n      }\n    };\n\n    this.handleClick = e => {\n      let node = e.target;\n\n      do {\n        if (this.isTabFromContainer(node)) {\n          if (isTabDisabled(node)) {\n            return;\n          }\n\n          const index = [].slice.call(node.parentNode.children).filter(isTabNode).indexOf(node);\n          this.setSelected(index, e);\n          return;\n        } // eslint-disable-next-line no-cond-assign\n\n      } while ((node = node.parentNode) != null);\n    };\n  }\n\n  setSelected(index, event) {\n    // Check index boundary\n    if (index < 0 || index >= this.getTabsCount()) return;\n    const {\n      onSelect,\n      selectedIndex\n    } = this.props; // Call change event handler\n\n    onSelect(index, selectedIndex, event);\n  }\n\n  getNextTab(index) {\n    const count = this.getTabsCount(); // Look for non-disabled tab from index to the last tab on the right\n\n    for (let i = index + 1; i < count; i++) {\n      if (!isTabDisabled(this.getTab(i))) {\n        return i;\n      }\n    } // If no tab found, continue searching from first on left to index\n\n\n    for (let i = 0; i < index; i++) {\n      if (!isTabDisabled(this.getTab(i))) {\n        return i;\n      }\n    } // No tabs are disabled, return index\n\n\n    return index;\n  }\n\n  getPrevTab(index) {\n    let i = index; // Look for non-disabled tab from index to first tab on the left\n\n    while (i--) {\n      if (!isTabDisabled(this.getTab(i))) {\n        return i;\n      }\n    } // If no tab found, continue searching from last tab on right to index\n\n\n    i = this.getTabsCount();\n\n    while (i-- > index) {\n      if (!isTabDisabled(this.getTab(i))) {\n        return i;\n      }\n    } // No tabs are disabled, return index\n\n\n    return index;\n  }\n\n  getFirstTab() {\n    const count = this.getTabsCount(); // Look for non disabled tab from the first tab\n\n    for (let i = 0; i < count; i++) {\n      if (!isTabDisabled(this.getTab(i))) {\n        return i;\n      }\n    }\n\n    return null;\n  }\n\n  getLastTab() {\n    let i = this.getTabsCount(); // Look for non disabled tab from the last tab\n\n    while (i--) {\n      if (!isTabDisabled(this.getTab(i))) {\n        return i;\n      }\n    }\n\n    return null;\n  }\n\n  getTabsCount() {\n    const {\n      children\n    } = this.props;\n    return getTabsCount(children);\n  }\n\n  getPanelsCount() {\n    const {\n      children\n    } = this.props;\n    return getPanelsCount(children);\n  }\n\n  getTab(index) {\n    return this.tabNodes[`tabs-${index}`];\n  }\n\n  getChildren() {\n    let index = 0;\n    const {\n      children,\n      disabledTabClassName,\n      focus,\n      forceRenderTabPanel,\n      selectedIndex,\n      selectedTabClassName,\n      selectedTabPanelClassName\n    } = this.props;\n    this.tabIds = this.tabIds || [];\n    this.panelIds = this.panelIds || [];\n    let diff = this.tabIds.length - this.getTabsCount(); // Add ids if new tabs have been added\n    // Don't bother removing ids, just keep them in case they are added again\n    // This is more efficient, and keeps the uuid counter under control\n\n    while (diff++ < 0) {\n      this.tabIds.push(uuid());\n      this.panelIds.push(uuid());\n    } // Map children to dynamically setup refs\n\n\n    return deepMap(children, child => {\n      let result = child; // Clone TabList and Tab components to have refs\n\n      if (isTabList(child)) {\n        let listIndex = 0; // Figure out if the current focus in the DOM is set on a Tab\n        // If it is we should keep the focus on the next selected tab\n\n        let wasTabFocused = false;\n\n        if (canUseActiveElement) {\n          wasTabFocused = React.Children.toArray(child.props.children).filter(isTab).some((tab, i) => document.activeElement === this.getTab(i));\n        }\n\n        result = cloneElement(child, {\n          children: deepMap(child.props.children, tab => {\n            const key = `tabs-${listIndex}`;\n            const selected = selectedIndex === listIndex;\n            const props = {\n              tabRef: node => {\n                this.tabNodes[key] = node;\n              },\n              id: this.tabIds[listIndex],\n              panelId: this.panelIds[listIndex],\n              selected,\n              focus: selected && (focus || wasTabFocused)\n            };\n            if (selectedTabClassName) props.selectedClassName = selectedTabClassName;\n            if (disabledTabClassName) props.disabledClassName = disabledTabClassName;\n            listIndex++;\n            return cloneElement(tab, props);\n          })\n        });\n      } else if (isTabPanel(child)) {\n        const props = {\n          id: this.panelIds[index],\n          tabId: this.tabIds[index],\n          selected: selectedIndex === index\n        };\n        if (forceRenderTabPanel) props.forceRender = forceRenderTabPanel;\n        if (selectedTabPanelClassName) props.selectedClassName = selectedTabPanelClassName;\n        index++;\n        result = cloneElement(child, props);\n      }\n\n      return result;\n    });\n  }\n\n  /**\n   * Determine if a node from event.target is a Tab element for the current Tabs container.\n   * If the clicked element is not a Tab, it returns false.\n   * If it finds another Tabs container between the Tab and `this`, it returns false.\n   */\n  isTabFromContainer(node) {\n    // return immediately if the clicked element is not a Tab.\n    if (!isTabNode(node)) {\n      return false;\n    } // Check if the first occurrence of a Tabs container is `this` one.\n\n\n    let nodeAncestor = node.parentElement;\n\n    do {\n      if (nodeAncestor === this.node) return true;\n      if (nodeAncestor.getAttribute(\"data-tabs\")) break;\n      nodeAncestor = nodeAncestor.parentElement;\n    } while (nodeAncestor);\n\n    return false;\n  }\n\n  render() {\n    // Delete all known props, so they don't get added to DOM\n    const {\n      children,\n      // unused\n      className,\n      disabledTabClassName,\n      // unused\n      domRef,\n      focus,\n      // unused\n      forceRenderTabPanel,\n      // unused\n      onSelect,\n      // unused\n      selectedIndex,\n      // unused\n      selectedTabClassName,\n      // unused\n      selectedTabPanelClassName,\n      // unused\n      ...attributes\n    } = this.props;\n    return /*#__PURE__*/React.createElement(\"div\", Object.assign({}, attributes, {\n      className: cx(className),\n      onClick: this.handleClick,\n      onKeyDown: this.handleKeyDown,\n      ref: node => {\n        this.node = node;\n        if (domRef) domRef(node);\n      },\n      \"data-tabs\": true,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 358,\n        columnNumber: 7\n      }\n    }), this.getChildren());\n  }\n\n}\nUncontrolledTabs.defaultProps = {\n  className: \"react-tabs\",\n  focus: false\n};\nUncontrolledTabs.propTypes = {\n  children: childrenPropType,\n  direction: PropTypes.oneOf([\"rtl\", \"ltr\"]),\n  className: PropTypes.oneOfType([PropTypes.string, PropTypes.array, PropTypes.object]),\n  disabledTabClassName: PropTypes.string,\n  domRef: PropTypes.func,\n  focus: PropTypes.bool,\n  forceRenderTabPanel: PropTypes.bool,\n  onSelect: PropTypes.func.isRequired,\n  selectedIndex: PropTypes.number.isRequired,\n  selectedTabClassName: PropTypes.string,\n  selectedTabPanelClassName: PropTypes.string\n};","map":{"version":3,"sources":["/Users/riteshgupta/Desktop/sjeiwebsite/src/components/UncontrolledTabs.js"],"names":["PropTypes","React","cloneElement","Component","cx","uuid","childrenPropType","getPanelsCount","getTabsCount","deepMap","isTabList","isTabPanel","isTab","isNode","node","isTabNode","getAttribute","isTabDisabled","canUseActiveElement","window","document","activeElement","e","UncontrolledTabs","tabNodes","handleKeyDown","direction","props","isTabFromContainer","target","selectedIndex","index","preventDefault","useSelectedIndex","keyCode","handleClick","getNextTab","getPrevTab","getLastTab","getFirstTab","setSelected","slice","call","parentNode","children","filter","indexOf","event","onSelect","count","i","getTab","getChildren","disabledTabClassName","focus","forceRenderTabPanel","selectedTabClassName","selectedTabPanelClassName","tabIds","panelIds","diff","length","push","child","result","listIndex","wasTabFocused","Children","toArray","some","tab","key","selected","tabRef","id","panelId","selectedClassName","disabledClassName","tabId","forceRender","nodeAncestor","parentElement","render","className","domRef","attributes","defaultProps","propTypes","oneOf","oneOfType","string","array","object","func","bool","isRequired","number"],"mappings":"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","sourcesContent":["import PropTypes from \"prop-types\";\nimport React, { cloneElement, Component } from \"react\";\nimport cx from \"clsx\";\nimport uuid from \"./helpers/uuid\";\nimport { childrenPropType } from \"./helpers/propTypes\";\nimport { getPanelsCount, getTabsCount } from \"./helpers/count\";\nimport { deepMap } from \"./helpers/childrenDeepMap\";\nimport { isTabList, isTabPanel, isTab } from \"./helpers/elementTypes\";\n\nfunction isNode(node) {\n  return node && \"getAttribute\" in node;\n}\n\n// Determine if a node from event.target is a Tab element\nfunction isTabNode(node) {\n  return isNode(node) && node.getAttribute(\"role\") === \"tab\";\n}\n\n// Determine if a tab node is disabled\nfunction isTabDisabled(node) {\n  return isNode(node) && node.getAttribute(\"aria-disabled\") === \"true\";\n}\n\nlet canUseActiveElement;\ntry {\n  canUseActiveElement = !!(\n    typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.activeElement\n  );\n} catch (e) {\n  // Work around for IE bug when accessing document.activeElement in an iframe\n  // Refer to the following resources:\n  // http://stackoverflow.com/a/10982960/369687\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12733599\n  canUseActiveElement = false;\n}\nexport default class UncontrolledTabs extends Component {\n  static defaultProps = {\n    className: \"react-tabs\",\n    focus: false\n  };\n\n  static propTypes = {\n    children: childrenPropType,\n    direction: PropTypes.oneOf([\"rtl\", \"ltr\"]),\n    className: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.array,\n      PropTypes.object\n    ]),\n    disabledTabClassName: PropTypes.string,\n    domRef: PropTypes.func,\n    focus: PropTypes.bool,\n    forceRenderTabPanel: PropTypes.bool,\n    onSelect: PropTypes.func.isRequired,\n    selectedIndex: PropTypes.number.isRequired,\n    selectedTabClassName: PropTypes.string,\n    selectedTabPanelClassName: PropTypes.string\n  };\n\n  tabNodes = [];\n\n  setSelected(index, event) {\n    // Check index boundary\n    if (index < 0 || index >= this.getTabsCount()) return;\n\n    const { onSelect, selectedIndex } = this.props;\n\n    // Call change event handler\n    onSelect(index, selectedIndex, event);\n  }\n\n  getNextTab(index) {\n    const count = this.getTabsCount();\n\n    // Look for non-disabled tab from index to the last tab on the right\n    for (let i = index + 1; i < count; i++) {\n      if (!isTabDisabled(this.getTab(i))) {\n        return i;\n      }\n    }\n\n    // If no tab found, continue searching from first on left to index\n    for (let i = 0; i < index; i++) {\n      if (!isTabDisabled(this.getTab(i))) {\n        return i;\n      }\n    }\n\n    // No tabs are disabled, return index\n    return index;\n  }\n\n  getPrevTab(index) {\n    let i = index;\n\n    // Look for non-disabled tab from index to first tab on the left\n    while (i--) {\n      if (!isTabDisabled(this.getTab(i))) {\n        return i;\n      }\n    }\n\n    // If no tab found, continue searching from last tab on right to index\n    i = this.getTabsCount();\n    while (i-- > index) {\n      if (!isTabDisabled(this.getTab(i))) {\n        return i;\n      }\n    }\n\n    // No tabs are disabled, return index\n    return index;\n  }\n\n  getFirstTab() {\n    const count = this.getTabsCount();\n\n    // Look for non disabled tab from the first tab\n    for (let i = 0; i < count; i++) {\n      if (!isTabDisabled(this.getTab(i))) {\n        return i;\n      }\n    }\n\n    return null;\n  }\n\n  getLastTab() {\n    let i = this.getTabsCount();\n\n    // Look for non disabled tab from the last tab\n    while (i--) {\n      if (!isTabDisabled(this.getTab(i))) {\n        return i;\n      }\n    }\n\n    return null;\n  }\n\n  getTabsCount() {\n    const { children } = this.props;\n    return getTabsCount(children);\n  }\n\n  getPanelsCount() {\n    const { children } = this.props;\n    return getPanelsCount(children);\n  }\n\n  getTab(index) {\n    return this.tabNodes[`tabs-${index}`];\n  }\n\n  getChildren() {\n    let index = 0;\n    const {\n      children,\n      disabledTabClassName,\n      focus,\n      forceRenderTabPanel,\n      selectedIndex,\n      selectedTabClassName,\n      selectedTabPanelClassName\n    } = this.props;\n\n    this.tabIds = this.tabIds || [];\n    this.panelIds = this.panelIds || [];\n    let diff = this.tabIds.length - this.getTabsCount();\n\n    // Add ids if new tabs have been added\n    // Don't bother removing ids, just keep them in case they are added again\n    // This is more efficient, and keeps the uuid counter under control\n    while (diff++ < 0) {\n      this.tabIds.push(uuid());\n      this.panelIds.push(uuid());\n    }\n\n    // Map children to dynamically setup refs\n    return deepMap(children, child => {\n      let result = child;\n\n      // Clone TabList and Tab components to have refs\n      if (isTabList(child)) {\n        let listIndex = 0;\n\n        // Figure out if the current focus in the DOM is set on a Tab\n        // If it is we should keep the focus on the next selected tab\n        let wasTabFocused = false;\n\n        if (canUseActiveElement) {\n          wasTabFocused = React.Children.toArray(child.props.children)\n            .filter(isTab)\n            .some((tab, i) => document.activeElement === this.getTab(i));\n        }\n\n        result = cloneElement(child, {\n          children: deepMap(child.props.children, tab => {\n            const key = `tabs-${listIndex}`;\n            const selected = selectedIndex === listIndex;\n\n            const props = {\n              tabRef: node => {\n                this.tabNodes[key] = node;\n              },\n              id: this.tabIds[listIndex],\n              panelId: this.panelIds[listIndex],\n              selected,\n              focus: selected && (focus || wasTabFocused)\n            };\n\n            if (selectedTabClassName)\n              props.selectedClassName = selectedTabClassName;\n            if (disabledTabClassName)\n              props.disabledClassName = disabledTabClassName;\n\n            listIndex++;\n\n            return cloneElement(tab, props);\n          })\n        });\n      } else if (isTabPanel(child)) {\n        const props = {\n          id: this.panelIds[index],\n          tabId: this.tabIds[index],\n          selected: selectedIndex === index\n        };\n\n        if (forceRenderTabPanel) props.forceRender = forceRenderTabPanel;\n        if (selectedTabPanelClassName)\n          props.selectedClassName = selectedTabPanelClassName;\n\n        index++;\n\n        result = cloneElement(child, props);\n      }\n\n      return result;\n    });\n  }\n\n  handleKeyDown = e => {\n    const { direction } = this.props;\n    if (this.isTabFromContainer(e.target)) {\n      let { selectedIndex: index } = this.props;\n      let preventDefault = false;\n      let useSelectedIndex = false;\n\n      if (e.keyCode === 32 || e.keyCode === 13) {\n        preventDefault = true;\n        useSelectedIndex = false;\n        this.handleClick(e);\n      }\n\n      if (e.keyCode === 37 || e.keyCode === 38) {\n        // Select next tab to the left\n        if (direction === \"rtl\") {\n          index = this.getNextTab(index);\n        } else {\n          index = this.getPrevTab(index);\n        }\n        preventDefault = true;\n        useSelectedIndex = true;\n      } else if (e.keyCode === 39 || e.keyCode === 40) {\n        // Select next tab to the right\n        if (direction === \"rtl\") {\n          index = this.getPrevTab(index);\n        } else {\n          index = this.getNextTab(index);\n        }\n        preventDefault = true;\n        useSelectedIndex = true;\n      } else if (e.keyCode === 35) {\n        // Select last tab (End key)\n        index = this.getLastTab();\n        preventDefault = true;\n        useSelectedIndex = true;\n      } else if (e.keyCode === 36) {\n        // Select first tab (Home key)\n        index = this.getFirstTab();\n        preventDefault = true;\n        useSelectedIndex = true;\n      }\n\n      // This prevents scrollbars from moving around\n      if (preventDefault) {\n        e.preventDefault();\n      }\n\n      // Only use the selected index in the state if we're not using the tabbed index\n      if (useSelectedIndex) {\n        this.setSelected(index, e);\n      }\n    }\n  };\n\n  handleClick = e => {\n    let node = e.target;\n    do {\n      if (this.isTabFromContainer(node)) {\n        if (isTabDisabled(node)) {\n          return;\n        }\n\n        const index = [].slice\n          .call(node.parentNode.children)\n          .filter(isTabNode)\n          .indexOf(node);\n        this.setSelected(index, e);\n        return;\n      }\n      // eslint-disable-next-line no-cond-assign\n    } while ((node = node.parentNode) != null);\n  };\n\n  /**\n   * Determine if a node from event.target is a Tab element for the current Tabs container.\n   * If the clicked element is not a Tab, it returns false.\n   * If it finds another Tabs container between the Tab and `this`, it returns false.\n   */\n  isTabFromContainer(node) {\n    // return immediately if the clicked element is not a Tab.\n    if (!isTabNode(node)) {\n      return false;\n    }\n\n    // Check if the first occurrence of a Tabs container is `this` one.\n    let nodeAncestor = node.parentElement;\n    do {\n      if (nodeAncestor === this.node) return true;\n      if (nodeAncestor.getAttribute(\"data-tabs\")) break;\n\n      nodeAncestor = nodeAncestor.parentElement;\n    } while (nodeAncestor);\n\n    return false;\n  }\n\n  render() {\n    // Delete all known props, so they don't get added to DOM\n    const {\n      children, // unused\n      className,\n      disabledTabClassName, // unused\n      domRef,\n      focus, // unused\n      forceRenderTabPanel, // unused\n      onSelect, // unused\n      selectedIndex, // unused\n      selectedTabClassName, // unused\n      selectedTabPanelClassName, // unused\n      ...attributes\n    } = this.props;\n\n    return (\n      <div\n        {...attributes}\n        className={cx(className)}\n        onClick={this.handleClick}\n        onKeyDown={this.handleKeyDown}\n        ref={node => {\n          this.node = node;\n          if (domRef) domRef(node);\n        }}\n        data-tabs\n      >\n        {this.getChildren()}\n      </div>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}